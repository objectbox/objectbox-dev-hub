---
id: realm-to-objectbox-migration
title: "Realm → ObjectBox Migration Guide"
sidebar_label: "Realm → ObjectBox migration"
description: "Step-by-step guide to migrate data and code from Realm to ObjectBox."
slug: /migrate/realm-to-objectbox/guide
keywords: [ObjectBox, Realm, migration, guide]
---

import Head from '@docusaurus/Head';

# Realm → ObjectBox Migration

This guide walks you through moving a project from **Realm** to **ObjectBox** with minimal downtime: planning, schema mapping, data export/import, and code changes.

## 1) Plan & inventory

- List entities, fields, relations, and indexes in Realm.

- Decide where many-to-many relations become relation entities or reciprocal <code>ToMany</code> in ObjectBox.
  <div className="explanation-list-box">
    <p>ObjectBox supports many-to-many relations, which can be modeled using a dedicated "link entity" or by using two <code>ToMany</code> relations that point to each other (a backlink). This is a necessary design decision during migration.</p>
    <p>Reference: <a href="https://docs.objectbox.io/relations#many-to-many-relations" target="_blank">ObjectBox Docs: Relations</a></p>
  </div>

- Identify fields that should become <strong>indexes</strong> in ObjectBox.
  <div className="explanation-list-box">
    <p>Just like in Realm, adding indexes in ObjectBox is crucial for query performance. Fields that are frequently used in query conditions are prime candidates for an index.</p>
    <p>Reference: <a href="https://docs.objectbox.io/advanced/indexes" target="_blank">ObjectBox Docs: Indexes</a></p>
  </div>

- Note any custom types requiring <strong>Converters</strong> in ObjectBox.
  <div className="explanation-list-box">
    <p>ObjectBox can only persist a specific set of standard property types. If your Realm model uses custom data types (e.g., <code>java.util.Date</code>), you must create a <code>PropertyConverter</code> to map them to a type that ObjectBox can store.</p>
    <p>Reference: <a href="https://docs.objectbox.io/advanced/custom-types" target="_blank">ObjectBox Docs: Custom Types using PropertyConverter</a></p>
  </div>

## 2) Schema mapping

Start with the [API mapping](./realm-to-objectbox-api-mapping.mdx) and replicate the domain model:

- Replace `RealmObject` models with `@Entity` classes/structs.
- Add `@Id` fields (auto-assigned IDs on insert by default).
- Add `@Index` on hot query fields.
- Add relation fields (e.g., `ToMany`) per binding conventions.

:::tip IDs 101
Unless you mark the ID as **assignable** (e.g., `@Id(assignable = true)` in Java/Kotlin), ObjectBox assigns IDs automatically on insert. For migrations where you must **preserve IDs**, enable assignable IDs and ensure uniqueness before `put()`.
:::

## 3) Data export from Realm

- Use Realm’s APIs to iterate and serialize objects to a neutral format (JSON/CSV/custom).
- Keep **foreign keys** or relation references in the export so you can re-link after import.
- For large datasets, export in **batches**.

## 4) Import into ObjectBox

- Create entities in ObjectBox mirroring the mapped schema.
- <strong>Transaction batching</strong>: use <code>{'store.runInTx { … }'}</code> and <code>box.put(collection)</code> to import efficiently.
  <div className="explanation-list-box">
    <p>This is the most efficient way to import data. Wrapping the operation in a transaction minimizes disk I/O, and using the <code>put(Collection)</code> method is significantly faster than putting objects one by one in a loop.</p>
    <p>Reference: <a href="https://docs.objectbox.io/transactions" target="_blank">ObjectBox Docs: Transactions</a> and <a href="https://docs.objectbox.io/performance/write-performance#bulk-operations-vs-single-operations" target="_blank">Write Performance</a></p>
  </div>

- Reconstruct relations after the base entities are inserted (you’ll have the new IDs if you didn’t preserve old ones).

<h3 id="import-tips">Import tips</h3>

- Validate each batch; log/skip malformed records.
- If preserving IDs, enable assignable IDs before calling `put()`.

## 5) Replace code paths

- Reads: `box.get(id)` / queries per binding.
- Writes: `box.put(obj or collection)`.
- Deletes: `box.remove(id|obj|collection)`.
- Wrap multi-step operations in a **transaction**.

## 6) Testing & verification

- Parity tests: compare counts, spot-check random samples.
- Query parity: replicate key Realm queries in ObjectBox; compare results.
- Performance baselines: measure cold/warm reads, writes, and batch operations.

## 7) Rollout

- Ship behind a feature flag if feasible.
- Keep a reversible path (backup exports) for the first versions.
- Monitor crash/error reports and data integrity metrics.

---

## See also
- [Realm → ObjectBox API Mapping](./realm-to-objectbox-api-mapping.mdx)
- [Transactions](./transactions.mdx)
- [box.put()](./box-put-method.mdx)
- [box.get()](./box-get-method.mdx)
- [box.remove()](./box-remove-method.mdx)

<Head>
  <script type="application/ld+json">{JSON.stringify({"@context": "https://schema.org", "@type": "TechArticle", "mainEntityOfPage": {"@type": "WebPage", "@id": "https://dev.objectbox.io/migrate/realm-to-objectbox/guide"}, "headline": "Realm → ObjectBox Migration Guide", "description": "Step-by-step guide to migrate data and code from Realm to ObjectBox", "keywords": "ObjectBox, Realm, Realm DB, Data Sync, MongoDB, MongoDB Atlas Device Sync, migration, guide", "datePublished": "2025-03-15T09:00:00+01:00", "dateModified": "2025-09-09T14:30:00+02:00", "author": {"@type": "Organization", "name": "ObjectBox", "url": "https://dev.objectbox.io/"}})}</script>
</Head>